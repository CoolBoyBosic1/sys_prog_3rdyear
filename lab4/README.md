# Лабораторна робота: Аналіз та вимір продуктивності 

Виконав: **CoolBoyBossic**
Програма для аналізу: Множення матриць (`matrix.c`)

---

## Етап 0: Підготовка та вихідний код

Для аналізу була обрана програма мовою C, яка виконує обчислювально-складну задачу — множення двох матриць `double` розміром `800x800`.

### 0.1) Вихідний код в `matrix.c`

### 0.2) Компіляція
Було створено дві версії програми: неоптимізована (`-O0`) та оптимізована (`-O3`).

**Неоптимізована версія:**
```bash
gcc -g -O0 matrix.c -o lab_program_unopt
```

**Оптимізована версія:**
```bash
gcc -g -O3 -march=native matrix.c -o lab_program_opt
```

---

## Фаза 1: Аналіз НЕОПТИМІЗОВАНОЇ програми (`lab_program_unopt`)

### Етап 1: Побудова та аналіз FlameGraph

#### 1.1) Процес побудови FlameGraph
Для побудови графіка були використані інструменти `perf` та скрипти Брендана Грегга.

**Команди, що виконувалися:**

``` bash
sudo perf record -F 99 -g -- ./lab_program_unopt

sudo perf script > out.perf

~/FlameGraph/stackcollapse-perf.pl out.perf > out.folded

~/FlameGraph/flamegraph.pl out.folded > program_unopt.svg
```

#### 1.2) Пояснення (інтерпретація) результатів

**FlameGraph неоптимізованої програми (`program_unopt.svg`):**

<img width="1207" height="187" alt="image" src="https://github.com/user-attachments/assets/1a92637e-3ed7-4627-a90a-dce589dec060" />


**Аналіз FlameGraph:**
На графіку чітко видно, що майже вся ширина (~99%) зайнята одним широким "плато" — функцією **`matrix_multiply`**. Функції `main` (яка її викликає) та `init_matrices` (яка запускалася до неї) займають незначну частку часу.

**Висновок:** Програма є **CPU-bound** (обмежена потужністю процесора). Функція `matrix_multiply` є абсолютним **вузьким місцем (bottleneck)**. Будь-які зусилля з оптимізації мають бути спрямовані саме на цю функцію.

---

### Етап 2: Збір та пояснення статистики

#### 2.1) `/usr/bin/time --verbose`

**Команда:**
```bash
/usr/bin/time -v ./lab_program_unopt
```

**Результат виконання:**
<img width="771" height="690" alt="image" src="https://github.com/user-attachments/assets/3ecccfe5-5acc-4884-a469-5f10cdbceacc" />


**Аналіз `/usr/bin/time -v`:**
* `User time (seconds): 6.43`: Час CPU, витрачений у коді програми.
* `Elapsed (wall clock) time ...: 0:06.44`: Реальний час виконання. Той факт, що "User time" (6.43 с) та "Elapsed time" (6.44 с) майже ідентичні, підтверджує, що програма повністю завантажила одне ядро CPU (`Percent of CPU: 99%`).
* `Maximum resident set size (kbytes): 16512`: Пікове використання RAM склало приблизно 16.5 МБ.
* `Major (requiring I/O) page faults: 0`: Ідеальний показник. Програма жодного разу не зверталася до повільного диска; все помістилося в RAM.

#### 2.2) `perf stat -d`

**Команда:**
```bash
sudo perf stat -d ./lab_program_unopt
```

**Результат виконання:**
<img width="1085" height="683" alt="image" src="https://github.com/user-attachments/assets/1bf58b99-6ef7-4e03-91f0-9484fd35c668" />


**Аналіз `perf stat -d`:**
* `2.38 insn per cycle (IPC)`: **Ключова метрика ефективності.** Процесор в середньому виконував 2.38 інструкції за один такт. Це високий показник, що підтверджує, що програма "забиває" обчислювальні блоки процесора (CPU-bound).
* `0.17% of all branches` (branch-misses): Відмінний показник. Рівень помилок передбачення переходів (циклів `for`) надзвичайно низький.
* `7.96% of all L1-dcache accesses` (L1-dcache-load-misses): Промахи кешу L1.
* `14.49% of all LL-cache accesses` (LLC-load-misses): Промахи кешу останнього рівня (L3). У ~14.5% випадків даних не було навіть у L3-кеші, і процесору доводилося звертатися до значно повільнішої оперативної пам'яті (RAM).

#### 2.3) `perf report`

**Команда:**
```bash
sudo perf report
```

**Результат виконання:**
нажаль скріншот не зберігся(((

**Аналіз `perf report`:**
У звіті видно, що функція **`matrix_multiply`** знаходиться на першому місці у списку з **99.70%** навантаження (стовпець `Self`). Це підтверджує дані, отримані з FlameGraph — ця функція є головним споживачем ресурсів CPU.

---

### Етап 3: Замір енерговитрат

#### 3.1) Енерговитрати системи
Виміряти середню потужність (Вати) всієї *системи* під час виконання програми за допомогою `powerstat` не вдалося. Інструмент вимагає мінімального часу вимірювання 300 секунд, тоді як наша програма виконується лише ~6.7 секунд.

Проте, було зафіксовано **фонове (Baseline) споживання** системи у стані спокою:
**~18.57 Вт** (на основі попередніх вимірів `powerstat`).

#### 3.2) Енерговитрати досліджуваної програми
Для вимірювання енергії, спожитої безпосередньо процесором, був використаний `perf stat` з подією `power/energy-pkg/` (Intel RAPL).

**Команда:**
```bash
sudo perf stat -e power/energy-pkg/ ./lab_program_unopt
```

**Результат виконання:**
<img width="910" height="275" alt="image" src="https://github.com/user-attachments/assets/0faf0463-23fb-4011-b71d-9efc02d5e70e" />


**Аналіз:**
* **Загальна енергія (CPU): 26.85 Джоулів**
* **Час:** 6.485 секунд
* **Середня потужність CPU (W = J/s):** 26.85 / 6.485 ≈ **4.14 Вт**

**Висновок:** Під час роботи програми, її головне навантаження (CPU) вийшло зі стану спокою і почало споживати в середньому **4.14 Вт** енергії.

---
---

## Фаза 2: Аналіз ОПТИМІЗОВАНОЇ програми (`lab_program_opt`)

### Етап 4: Порівняння параметрів До та Після оптимізації

#### 4.1) Пояснення різниці в асемблерному коді (та 4.1.1 AVX/SIMD)
Для аналізу асемблерного коду були згенеровані лістинги обох версій:

```
objdump -d -S ./lab_program_unopt > unopt.asm
objdump -d -S ./lab_program_opt > opt.asm
```

**Аналіз асемблерного коду:**
* **Версія `-O0` (unopt.asm):** Код є "наївним". Внутрішній цикл множення виконує **скалярні** операції з плаваючою комою (напр., `mulsd`, `addsd`). Кожна операція працює лише з **одним** 64-бітним числом. Спостерігається велика кількість звернень до пам'яті (`movsd`).

* **Версія `-O3 -march=native` (opt.asm):** Компілятор повністю трансформував логіку.
    * **Розгортання циклів (Loop Unrolling):** Компілятор виконує кілька операцій за одну ітерацію циклу, щоб зменшити накладні витрати на переходи.
    * **Векторизація (SIMD - Пункт 4.1.1):** Код активно використовує інструкції **AVX/SSE**. Замість `mulsd` (скалярне множення), використовуються **векторні** інструкції (наприклад, **`vmulpd`**, **`vaddpd`**) та **`ymm`** (256-бітні) або **`xmm`** (128-бітні) регістри.
    * **Що це дає:** Інструкція `vmulpd ymm0, ymm1, ymm2` виконує **чотири** 64-бітних множення `double` **за одну операцію**. Це дає величезне прискорення математичних обчислень.

#### 4.2) Порівняння часу та інших показників

**Команди:**
```bash
/usr/bin/time -v ./lab_program_opt
sudo perf stat -d ./lab_program_opt
```

**Результати виконання:**
<img width="757" height="642" alt="image" src="https://github.com/user-attachments/assets/ea47f94a-9046-405b-9931-9fc06621e415" />

<img width="1064" height="607" alt="image" src="https://github.com/user-attachments/assets/adfb91a0-505c-4abe-b92b-dbcf5b3585ff" />


**Порівняльна таблиця:**

| Метрика | `lab_program_unopt` (-O0) | `lab_program_opt` (-O3) | Зміна |
| :--- | :--- | :--- | :--- |
| **User time (`time`)** | 6.43 с | **0.60 с** | **-90.7% (в 10.7 разів швидше!)** |
| **Cycles (`perf`)** | ~12.94 млрд | **~1.01 млрд** | **-92.2%** |
| **Instructions (`perf`)** | ~31.32 млрд | **~0.80 млрд** | **-97.4%** |
| **IPC (`perf`)** | 2.42 | **0.79** | **-67.4% (Падіння)** |
| **L1-dcache-misses** | 7.96% | **50.97%** | **+540% (Значно гірше)** |
| **LLC-load-misses** | 13.99% | **46.26%** | **+230% (Значно гірше)** |

**Інтерпретація:**
1.  **Час та Інструкції:** Програма стала **в 10.7 разів швидшою** (0.6 с проти 6.43 с). Головна причина — компілятор використав **SIMD-інструкції (AVX)**, як ми бачили в асемблерному коді (Пункт 4.1). Це підтверджується **величезним падінням кількості інструкцій** (з 31 до 0.8 мільярда) — одна SIMD-інструкція виконує роботу десятків скалярних.
2.  **Парадокс IPC та кешу:** Найцікавіше — це падіння **IPC** (інструкцій за цикл) з 2.42 до 0.79. Програма стала швидшою, але *менш ефективною* з точки зору кожного такту CPU.
3.  **Причина:** Це пояснюється **катастрофічним зростанням промахів кешу** (L1-misses з ~8% до ~51%, LLC-misses з ~14% до ~46%).
4.  **Висновок:** Оптимізація змінила "вузьке місце". Неоптимізована версія була **CPU-bound** (обмежена швидкістю обчислень). Оптимізована версія стала **Memory-bound** (обмежена швидкістю пам'яті). SIMD-інструкції "рахують" так швидко, що процесор тепер змушений *простоювати* (IPC впав), чекаючи, поки дані прийдуть з повільної RAM.

#### 4.3) Демонстрація змін на FlameGraph

**Команди:**
```bash
sudo perf record -F 99 -g -- ./lab_program_opt
sudo perf script > out_opt.perf
~/FlameGraph/stackcollapse-perf.pl out_opt.perf > out_opt.folded
~/FlameGraph/flamegraph.pl out_opt.folded > program_opt.svg
```

**Результат (`program_opt.svg`):**
<img width="1254" height="431" alt="Screenshot from 2025-11-07 10-15-50" src="https://github.com/user-attachments/assets/777ab2ff-1816-41f6-a230-449101c1ed53" />


**Аналіз FlameGraph (До/Після):**
* **До (`unopt`):** Графік мав одну величезну "гору" — `matrix_multiply` (~99%).
* **Після (`opt`):** Графік став набагато "нижчим". Функція `matrix_multiply` стала **набагато вужчою**, оскільки тепер виконується в 11 разів швидше. Через це **інші функції**, як-от `init_matrices` (стовпчик зліва), які раніше були невидимими (0.3%), тепер займають **значно більший відсоток** від загального (скороченого) часу. Це наочно демонструє, що вузьке місце було успішно оптимізовано.

#### 4.4) Порівняння енерговитрат

**Команда:**
```bash
sudo perf stat -e power/energy-pkg/ ./lab_program_opt
```

**Результат виконання:**
<img width="899" height="282" alt="image" src="https://github.com/user-attachments/assets/e65af481-ecfa-44eb-972a-8912f754f9c7" />

**Порівняльна таблиця:**

| Метрика | `lab_program_unopt` (-O0) | `lab_program_opt` (-O3) | Зміна |
| :--- | :--- | :--- | :--- |
| **Час виконання** | 6.485 с | **0.585 с** | **-91.0%** |
| **Енергія (Joules)**| 26.85 Дж | **2.29 Дж** | **-91.5%** |
| **Сер. потужність CPU**| ~4.14 Вт | **~3.91 Вт** | **-5.6%** |

**Загальний висновок:**
Оптимізація (`-O3`) не лише зробила програму **в ~11 разів швидшою** (0.58 с проти 6.48 с), але й **на 91.5% енергоефективнішою**. Програма виконала ту саму роботу, витративши **в ~11.7 разів менше загальної енергії** (2.29 Дж проти 26.85 Дж).

Падіння середньої миттєвої потужності (з 4.14 Вт до 3.91 Вт) ще раз підтверджує, що оптимізована програма частіше простоювала, очікуючи на дані з пам'яті (Memory-bound).
